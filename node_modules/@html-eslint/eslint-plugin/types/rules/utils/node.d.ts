export type Attribute = import("../../types").Attribute;
export type Tag = import("../../types").Tag;
export type ScriptTag = import("../../types").ScriptTag;
export type StyleTag = import("../../types").StyleTag;
export type Line = import("../../types").Line;
export type Text = import("../../types").Text;
export type CommentContent = import("../../types").CommentContent;
export type Comment = import("../../types").Comment;
export type AnyNode = import("../../types").AnyNode;
export type AttributeValue = import("../../types").AttributeValue;
export type AttributeKey = import("../../types").AttributeKey;
export type TemplateText = import("../../types").TemplateText;
export type OpenTemplate = import("../../types").OpenTemplate;
export type CloseTemplate = import("../../types").CloseTemplate;
export type AnyPartNode = import("../../types").AnyPartNode;
export type Range = import("eslint").AST.Range;
export type SourceLocation = import("eslint").AST.SourceLocation;
export type AnyToken = import("es-html-parser").AnyToken;
/**
 * @param {Tag | ScriptTag | StyleTag} node
 * @param {string} key
 * @returns {Attribute | undefined}
 */
export function findAttr(node: Tag | ScriptTag | StyleTag, key: string): Attribute | undefined;
/**
 * Checks whether a node's attributes is empty or not.
 * @param {Tag | ScriptTag | StyleTag} node
 * @returns {boolean}
 */
export function isAttributesEmpty(node: Tag | ScriptTag | StyleTag): boolean;
/**
 * Checks whether a node's all tokens are on the same line or not.
 * @param {AnyNode} node A node to check
 * @returns {boolean} `true` if a node's tokens are on the same line, otherwise `false`.
 */
export function isNodeTokensOnSameLine(node: AnyNode): boolean;
/**
 *
 * @param {Text | CommentContent} node
 * @returns {Line[]}
 */
export function splitToLineNodes(node: Text | CommentContent): Line[];
/**
 * Get location between two nodes.
 * @param {{loc: SourceLocation}} before A node placed in before
 * @param {{loc: SourceLocation}} after A node placed in after
 * @returns {SourceLocation} location between two nodes.
 */
export function getLocBetween(before: {
    loc: SourceLocation;
}, after: {
    loc: SourceLocation;
}): SourceLocation;
/**
 * @param {Exclude<AnyNode, Line>} node
 * @param {(node: AnyNode) => boolean} predicate
 * @returns {null | AnyNode}
 */
export function findParent(node: Exclude<AnyNode, Line>, predicate: (node: AnyNode) => boolean): null | AnyNode;
/**
 * @param {AnyNode} node
 * @returns {node is Tag}
 */
export function isTag(node: AnyNode): node is Tag;
/**
 * @param {AnyNode} node
 * @returns {node is Comment}
 */
export function isComment(node: AnyNode): node is Comment;
/**
 * @param {AnyNode} node
 * @returns {node is Text}
 */
export function isText(node: AnyNode): node is Text;
/**
 * @param {AnyNode | Line | TemplateText | OpenTemplate | CloseTemplate } node
 * @returns {node is Line}
 */
export function isLine(node: AnyNode | Line | TemplateText | OpenTemplate | CloseTemplate): node is Line;
/**
 * @param {AnyNode} node
 * @returns {node is ScriptTag}
 */
export function isScript(node: AnyNode): node is ScriptTag;
/**
 * @param {AnyNode} node
 * @returns {node is StyleTag}
 */
export function isStyle(node: AnyNode): node is StyleTag;
/**
 * @param {(Text | CommentContent)['parts']} parts
 * @param {Range} range
 * @returns {boolean}
 */
export function isOverlapWithTemplates(parts: (Text | CommentContent)["parts"], range: Range): boolean;
/**
 * @param {string} source
 * @returns {string[]}
 */
export function codeToLines(source: string): string[];
/**
 *
 * @param {Range} rangeA
 * @param {Range} rangeB
 * @returns {boolean}
 */
export function isRangesOverlap(rangeA: Range, rangeB: Range): boolean;
/**
 *
 * @param {AnyToken[]} tokens
 * @returns {((CommentContent | Text)['parts'][number])[]}
 */
export function getTemplateTokens(tokens: AnyToken[]): ((CommentContent | Text)["parts"][number])[];
/**
 * @param {AttributeKey | AttributeValue | Text | CommentContent} node
 * @returns {boolean}
 */
export function hasTemplate(node: AttributeKey | AttributeValue | Text | CommentContent): boolean;
//# sourceMappingURL=node.d.ts.map