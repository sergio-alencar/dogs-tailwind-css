import Config from "./config.js";
import { extract_inline_config } from "./inline_config.js";
import rules from "./rules/index.js";
import Issue, { ISSUE_SEVERITY } from "./issue.js";
import CustomError from "./utils/custom-errors.js";
import { get_module_path } from "./read-config.js";
/**
 * Apply the raw-ignore-regex option.
 * Return the modified html, and a function that recovers line/column
 * numbers of issues.
 */
function raw_ignore_regex(html, options) {
    const ignore = options["raw-ignore-regex"];
    if (!ignore) {
        return html;
    }
    // TODO: Remove `as ...` after adding validation to `x-regex` property in config files
    return html.replace(new RegExp(ignore, "gm"), function (match) {
        return match.replace(/[^\n\t\n\r]/g, "Â¤");
    });
}
function merge_inline_config(base_config, new_config) {
    const merged_config = Object.keys(new_config).reduce((merged_config, rule_name) => {
        if (base_config[rule_name]) {
            merged_config[rule_name] = {
                ...base_config[rule_name],
                ...new_config[rule_name]
            };
        }
        else {
            merged_config[rule_name] = new_config[rule_name];
        }
        return merged_config;
    }, {});
    return {
        ...base_config,
        ...merged_config
    };
}
function get_parser(config) {
    if (config === null || config === void 0 ? void 0 : config.parser) {
        try {
            const parser_module = get_module_path(process.cwd(), config.parser);
            // eslint-disable-next-line  @typescript-eslint/no-unsafe-member-access
            return import(parser_module).then((parser) => { var _a; return ((_a = parser.default) !== null && _a !== void 0 ? _a : parser); });
        }
        catch (error) {
            // @ts-expect-error system error with meta object
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
            throw new CustomError("CORE-04", { module_name: error.meta.module_name });
        }
    }
    // Eslint Typescript recommend using import statement but import return a promise.
    /* eslint-disable-next-line @typescript-eslint/no-var-requires */
    return import("@linthtml/html-parser").then((parser) => { var _a; return (_a = parser.default) !== null && _a !== void 0 ? _a : parser; });
}
export default class Linter {
    constructor(config) {
        this.get_parse_fn = () => get_parser(config);
        // this.parse_fn = get_parser(config);
        this.config = new Config(rules, config);
    }
    /**
     * Lints the HTML with the options supplied in the environments setup.
     */
    async lint(html) {
        html = raw_ignore_regex(html, this.config.config);
        const parse_fn = await this.get_parse_fn();
        const dom = parse_fn(html);
        const activated_rules = Object.keys(this.config.activated_rules).map((name) => this.config.activated_rules[name]);
        const rules_deprecated_issues = this.report_deprecated_rules(activated_rules);
        const dom_issues = this.lint_DOM(activated_rules, dom);
        let issues = [...rules_deprecated_issues, ...dom_issues, ...this.reset_rules()];
        if (this.config.config.maxerr) {
            issues = issues.slice(0, this.config.config.maxerr); // REMOVE: After v1.
        }
        return Promise.resolve(issues);
    }
    report_deprecated_rules(activated_rules) {
        return activated_rules
            .filter(({ deprecated }) => deprecated)
            .map((rule) => new Issue("", null, {
            code: "DEPRECATED_RULE",
            severity: ISSUE_SEVERITY.WARNING,
            data: {
                rule_name: rule.name,
                hint: rule.deprecation_hint
            }
        }));
    }
    lint_DOM(rules, dom) {
        const issues = [];
        // merge with report in call_rule_lint ?
        function report_inline_config(data) {
            const meta = {
                ...data.meta,
                severity: "error",
                code: data.code
            };
            issues.push(new Issue("inline_config", data.position, meta));
        }
        const getIssues = (node, parent_inline_config) => {
            let issues = rules.reduce((issues, rule) => [...issues, ...this.call_rule_lint(rule, node, parent_inline_config)], []);
            if (node.children && node.children.length > 0) {
                let inline_config = {
                    ...parent_inline_config
                };
                node.children.forEach((child) => {
                    const extracted_inline_config = extract_inline_config(child, this.config, report_inline_config);
                    inline_config = merge_inline_config(inline_config, extracted_inline_config);
                    issues = [...issues, ...getIssues(child, inline_config)];
                });
            }
            return issues;
        };
        let inline_config = {};
        const rules_issues = dom.children.map((node) => {
            const extracted_inline_config = extract_inline_config(node, this.config, report_inline_config);
            inline_config = merge_inline_config(inline_config, extracted_inline_config);
            return getIssues(node, inline_config);
        });
        return [...issues, ...rules_issues.flat()];
    }
    // TODO: Remove after v1
    call_rule_lint(rule, node, inline_config) {
        var _a, _b, _c, _d;
        const issues = [];
        function report(data) {
            const meta = {
                ...data.meta,
                severity: rule.severity,
                code: data.code,
                message: data.message
            };
            issues.push(new Issue(rule.name, data.position, meta));
        }
        if (((_a = inline_config[rule.name]) === null || _a === void 0 ? void 0 : _a.disabled) === true) {
            // inline_config[rule.name]?.disabled
            return issues;
        }
        const rule_config = (_c = (_b = inline_config[rule.name]) === null || _b === void 0 ? void 0 : _b.config) !== null && _c !== void 0 ? _c : this.config.legacy_config[rule.name];
        const global_config = ((_d = inline_config[rule.name]) === null || _d === void 0 ? void 0 : _d.config)
            ? {
                ...this.config.legacy_config,
                [rule.name]: inline_config[rule.name].config
            }
            : this.config.legacy_config;
        rule.lint(node, rule_config, {
            report,
            rules: this.config.activated_rules,
            global_config
        });
        return issues;
    }
    reset_rules() {
        const activated_rules = Object.keys(this.config.activated_rules);
        return activated_rules.reduce((issues, name) => {
            var _a, _b;
            const rule = this.config.getRule(name);
            const r = (_b = (_a = rule.end) === null || _a === void 0 ? void 0 : _a.call(rule)) !== null && _b !== void 0 ? _b : [];
            return [...issues, ...r];
        }, []);
    }
}
