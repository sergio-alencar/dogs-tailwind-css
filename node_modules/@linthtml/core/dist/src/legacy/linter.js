import parse from "@linthtml/html-parser";
import Config from "./config.js";
import InlineConfig from "./inline_config.js";
import rules from "../rules/index.js";
import Issue, { ISSUE_SEVERITY } from "../issue.js";
import { is_comment_node } from "@linthtml/dom-utils";
/**
 * Apply the raw-ignore-regex option.
 * Return the modified html, and a function that recovers line/column
 * numbers of issues.
 */
function rawIgnoreRegex(html, opts) {
    const ignore = opts["raw-ignore-regex"];
    if (!ignore) {
        return html;
    }
    return html.replace(new RegExp(ignore, "gm"), function (match) {
        return match.replace(/[^\n\t\n\r]/g, "Â¤");
    });
}
export default class Linter {
    constructor(_rules, ..._config) {
        const config = _config.reduce((obj, cell) => ({
            ...obj,
            ...cell
        }), {});
        delete config.ignoreFiles;
        this.config = config;
        _rules = _rules || rules;
        this.rules = new Config(_rules);
        this.inlineConfig = new InlineConfig(this.rules);
    }
    use(plugin) {
        if (plugin.rules) {
            plugin.rules.forEach((rule) => this.rules.addRule(rule));
        }
    }
    /**
     * Lints the HTML with the options supplied in the environments setup.
     * @param {String} html - the html as a string to lint.
     * @returns {import('../issue')[]}
     */
    lint(html) {
        let issues = [];
        this.inlineConfig = new InlineConfig(this.rules);
        this.rules.initOptions(this.config);
        html = rawIgnoreRegex(html, this.config);
        const dom = parse(html);
        issues = issues.concat(this.reportDeprecatedRules());
        issues = issues.concat(this.setupInlineConfigs(dom));
        try {
            issues = issues.concat(this.lintDom(dom, this.config));
        }
        finally {
            issues = issues.concat(this.resetRules(this.config));
        }
        if (this.config.maxerr) {
            issues = issues.slice(0, this.config.maxerr);
        }
        return Promise.resolve(issues);
    }
    reportDeprecatedRules() {
        var _a, _b;
        return ((_b = (_a = this.rules
            .getRule("dom")
            .subscribers) === null || _a === void 0 ? void 0 : _a.filter(({ deprecated }) => deprecated).map((rule) => new Issue("", null, {
            code: "DEPRECATED_RULE",
            severity: ISSUE_SEVERITY.WARNING,
            data: {
                rule_name: rule.name,
                hint: rule.deprecation_hint
            }
        }))) !== null && _b !== void 0 ? _b : []);
    }
    // Here ignore ts error as "dom" is special rule.
    lintDom(dom, opts) {
        // @ts-expect-error dom rule return an array (legacy code)
        return this.rules.getRule("dom").lint(dom, opts, this.inlineConfig);
    }
    resetRules(opts) {
        const rules = this.rules.getAllRules().map((rule) => {
            const r = rule.end && rule.end(opts);
            return r || [];
        });
        return rules.flat();
    }
    setupInlineConfigs(dom) {
        let issues = [];
        const { inlineConfig } = this;
        function feedComments(element) {
            if (is_comment_node(element)) {
                issues = issues.concat(inlineConfig.feedComment(element));
            }
            if (element.children) {
                element.children.map(feedComments);
            }
        }
        dom.children.forEach(feedComments.bind(this));
        return issues;
    }
}
