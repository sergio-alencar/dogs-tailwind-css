import { ElementType } from 'domelementtype';
import { types } from 'node:util';

const { isRegExp } = types;
/**
 * Check if a node is self closed or not (`<hr />, <input ... />, <foo />`)
 */
function is_self_closing(node) {
    const openRaw = node.open.raw; // Force raw presence for Element?
    return /\/>$/.test(openRaw);
}
/**
 * Check whether the given tag has an attribute with the given
 * name.
 */
function has_attribute(node, attribute_name) {
    return is_tag_node(node) ? node.attributes.some(({ name }) => name.chars.toLowerCase() === attribute_name) : false;
}
/**
 * Check whether the given tag has a non-empty attribute with the given name.
 * Empty string (`""`) is accepted if optional parameter `allow_null` is true
 */
function has_non_empty_attribute(node, attribute_name, allow_null = false) {
    const attribute = node.attributes.find(({ name }) => name.chars.toLowerCase() === attribute_name);
    return !!attribute && (allow_null || (!!attribute.value && attribute.value.chars.length > 0));
}
// Find a way to make this generic
// type LangAttribute = { chars: 'lang' } & NodeAttribute ;
/**
 * Get an attribute of a node element
 */
function get_attribute(node, attribute_name) {
    if (has_attribute(node, attribute_name)) {
        return node.attributes.find(({ name }) => name.chars.toLowerCase() === attribute_name);
    }
    return null;
}
/**
 * Get the value of an attribute for a node element
 */
function attribute_value(node, attribute_name) {
    var _a;
    const attribute = get_attribute(node, attribute_name);
    return (_a = attribute === null || attribute === void 0 ? void 0 : attribute.value) !== null && _a !== void 0 ? _a : null;
}
/**
 * Check whether an attribute has a value or not
 */
function attribute_has_value(node, attribute_name, value_to_check) {
    const value = attribute_value(node, attribute_name);
    if (value) {
        return isRegExp(value_to_check) ? value_to_check.test(value.chars) : value.chars === value_to_check;
    }
    return false;
}
/**
 * Check if a node is an Element node (div, span,... + style and script)
 */
function is_tag_node(node) {
    return [ElementType.Tag, ElementType.Style, ElementType.Script].indexOf(node.type) !== -1;
}
// TODO: check is current node text have `.loc` property if yes then create class Text_Node in dom_element.ts
/**
 * Check if a node is a Text node
 */
function is_text_node(node) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
    return node.type === ElementType.Text;
}
/**
 * Check if a node is a Comment node (`<!-- a comment -->`)
 */
function is_comment_node(node) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
    return node.type === ElementType.Comment;
}
function is_directive_node(node) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
    return node.type === ElementType.Directive;
}
// TODO find a way to have template type NodeAttribute<"class">
/**
 * Extract all html class for the class attribute
 */
function get_classes(class_attribute) {
    var _a, _b;
    const classes = (_b = (_a = class_attribute === null || class_attribute === void 0 ? void 0 : class_attribute.value) === null || _a === void 0 ? void 0 : _a.chars) !== null && _b !== void 0 ? _b : "";
    return classes.trim().split(/\s+/);
}
/**
 * Return the name of a node (Comment, Text node, div, span...)
 */
function node_tag_name(node) {
    switch (node.type) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        case ElementType.Text:
            return "Text Node"; // get text node content but truncate ?
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        case ElementType.Comment:
            return "Comment";
        default:
            // TODO: Check function with other types (CDATA, doctype...)
            return node.name;
    }
}
/**
 * Check if a node has a parent node
 */
function has_parent_node(node) {
    // root node is not a "normal" node
    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
    return !!node.parent && node.parent.type !== ElementType.Root;
}

export { attribute_has_value, attribute_value, get_attribute, get_classes, has_attribute, has_non_empty_attribute, has_parent_node, is_comment_node, is_directive_node, is_self_closing, is_tag_node, is_text_node, node_tag_name };
